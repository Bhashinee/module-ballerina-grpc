public client class {{serviceName}}{{#equals stubType "blocking"}}Blocking{{/equals}}Client {

    *grpc:AbstractClientEndpoint;

    private grpc:Client grpcClient;

    public isolated function init(string url, grpc:ClientConfiguration? config = ()) {
        // initialize client endpoint.
        self.grpcClient = new(url, config);
        checkpanic self.grpcClient.initStub(self, "{{stubType}}", ROOT_DESCRIPTOR, getDescriptorMap());
    }
{{#unaryFunctions}}
    isolated remote function {{methodName}}({{#if inputType}}{{inputType}} req, {{/if}}grpc:Headers? headers = ()) returns ({{#if outputType}}[{{outputType}}, grpc:Headers]{{else}}grpc:Headers{{/if}}|grpc:Error) {
        {{#unless inputType}}Empty req = {};{{/unless}}
        var payload = check self.grpcClient->blockingExecute("{{methodId}}", req, headers);
        grpc:Headers resHeaders = new;
        {{#if outputType}}anydata result = ();
        [result, resHeaders] = payload;
        {{#not_equal outputType "string"}}
        return [<{{outputType}}>result, resHeaders];
        {{/not_equal}}{{#equals outputType "string"}}return [result.toString(), resHeaders];{{/equals}}{{else}}[_, resHeaders] = payload;
        return resHeaders;{{/if}}
    }
{{/unaryFunctions}}{{#serverStreamingFunctions}}
    isolated remote function {{methodName}}({{#if inputType}}{{inputType}} req, {{/if}}grpc:Headers? headers = ()) returns (grpc:Error?) {
        {{#unless inputType}}Empty req = {};{{/unless}}
        return self.grpcClient->nonBlockingExecute("{{methodId}}", req, headers);
    }
{{/serverStreamingFunctions}}{{#clientStreamingFunctions}}
    isolated remote function {{methodName}}(grpc:Headers? headers = ()) returns ({{pascalcase methodName}}StreamingClient|grpc:Error) {
        StreamingClient sClient = check self.grpcClient->streamingExecute("{{methodId}}", headers);
        return new {{pascalcase methodName}}StreamingClient(sClient);
    }{{/clientStreamingFunctions}}
}

{{#clientStreamingFunctions}}
{{>streaming_client}}{{/clientStreamingFunctions}}