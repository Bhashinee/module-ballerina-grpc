public client class {{serviceName}}{{#equals stubType "blocking"}}Blocking{{/equals}}Client {

    *grpc:AbstractClientEndpoint;

    private grpc:Client grpcClient;

    public isolated function init(string url, grpc:ClientConfiguration? config = ()) {
        // initialize client endpoint.
        self.grpcClient = new(url, config);
        checkpanic self.grpcClient.initStub(self, ROOT_DESCRIPTOR, getDescriptorMap());
    }
{{#unaryFunctions}}
    isolated remote function {{methodName}}({{#if inputType}}{{inputType}}|Context{{removeSpecialCharacters inputType}} req{{/if}}) returns ({{#if outputType}}{{outputType}}|{{else}}grpc:Error{{/if}}) {
        {{#unless inputType}}Empty message = {};{{/unless}}
        map<string[]> headers = {};
        {{#if inputType}}{{inputType}} message;
        if (req is Context{{removeSpecialCharacters inputType}}) {
            message = req.content;
            headers = req.headers;
        } else {
            message = req;
        }{{/if}}
        var payload = check self.grpcClient->blockingExecute("{{methodId}}", message, headers);
        {{#if outputType}}anydata result;
        [][result, _] = payload;
        {{#not_equal outputType "string"}}
        return <{{outputType}}>result;
        {{/not_equal}}{{#equals outputType "string"}}return result.toString();{{/equals}}{{/if}}
    }

    isolated remote function {{methodName}}Context({{#if inputType}}{{inputType}}|Context{{removeSpecialCharacters inputType}} req{{/if}}) returns ({{#if outputType}}Context{{removeSpecialCharacters outputType}}|{{else}}grpc:Error{{/if}}) {
        {{#unless inputType}}Empty message = {};{{/unless}}
        map<string[]> headers = {};
        {{#if inputType}}{{inputType}} message;
        if (req is Context{{removeSpecialCharacters inputType}}) {
            message = req.content;
            headers = req.headers;
        } else {
            message = req;
        }{{/if}}
        var payload = check self.grpcClient->blockingExecute("{{methodId}}", message, headers);
        {{#if outputType}}[anydata, map<string[]>][result, resHeaders] = payload;
        {{#not_equal outputType "string"}}
        return { content: <{{outputType}}>result, headers: resHeaders };
        {{/not_equal}}{{#equals outputType "string"}}return { content: result.toString(), headers: resHeaders };{{/equals}}{{else}}[anydata, map<string[]>][_, resHeaders] = payload;
        return { headers: resHeaders };{{/if}}
    }
{{/unaryFunctions}}{{#serverStreamingFunctions}}
    isolated remote function {{methodName}}({{#if inputType}}{{inputType}}|Context{{removeSpecialCharacters inputType}} req{{/if}}) returns ({{#if outputType}}stream<{{outputType}}>|{{else}}grpc:Error{{/if}}) {
        {{#unless inputType}}Empty message = {};{{/unless}}
        map<string[]> headers = {};
        {{#if inputType}}{{inputType}} message;
        if (req is Context{{removeSpecialCharacters inputType}}) {
            message = req.content;
            headers = req.headers;
        } else {
            message = req;
        }{{/if}}
        return self.grpcClient->executeServerStreaming("{{methodId}}", message, headers);
    }

    isolated remote function {{methodName}}Context({{#if inputType}}{{inputType}}|Context{{removeSpecialCharacters inputType}} req{{/if}}) returns ({{#if outputType}}Context{{removeSpecialCharacters outputType}}|{{else}}grpc:Error{{/if}}) {
        {{#unless inputType}}Empty req = {};{{/unless}}
        map<string[]> headers = {};
        {{#if inputType}}{{inputType}} message;
        if (req is Context{{removeSpecialCharacters inputType}}) {
            message = req.content;
            headers = req.headers;
        } else {
            message = req;
        }{{/if}}
        stream<anydata> payload = check self.grpcClient->executeServerStreaming("{{methodId}}", message, headers);
        return {content: payload, headers: {}};
    }
{{/serverStreamingFunctions}}{{#clientStreamingFunctions}}
    isolated remote function {{methodName}}(map<string[]> headers = {}) returns ({{pascalcase methodName}}StreamingClient|grpc:Error) {
        StreamingClient sClient = check self.grpcClient->executeClientStreaming("{{methodId}}", headers);
        return new {{pascalcase methodName}}StreamingClient(sClient);
    }
{{/clientStreamingFunctions}}{{#bidiStreamingFunctions}}
    isolated remote function {{methodName}}(map<string[]> headers = {}) returns ({{pascalcase methodName}}StreamingClient|grpc:Error) {
    StreamingClient sClient = check self.grpcClient->executeClientStreaming("{{methodId}}", headers);
    return new {{pascalcase methodName}}StreamingClient(sClient);
    }{{/bidiStreamingFunctions}}
}

{{#clientStreamingFunctions}}
{{>streaming_client}}{{/clientStreamingFunctions}}{{#bidiStreamingFunctions}}
{{>streaming_client}}{{/bidiStreamingFunctions}}
{{#each valueTypeMap}}
{{>content_context}}
{{/each}}